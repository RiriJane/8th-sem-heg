# TABLE DES MATIERES
1. [Révision POO](https://github.com/RiriJane/8th-sem-heg/blob/main/63-31%20Prog%203/63-31_prog3.md#revision-programmation-orientee-objets)
    - [Encapsulation](https://github.com/RiriJane/8th-sem-heg/blob/main/63-31%20Prog%203/63-31_prog3.md#encapsulation)
    - [Visibilité de l'information](https://github.com/RiriJane/8th-sem-heg/blob/main/63-31%20Prog%203/63-31_prog3.md#visibilit%C3%A9-de-linformation)
    - [Abstraction](https://github.com/RiriJane/8th-sem-heg/blob/main/63-31%20Prog%203/63-31_prog3.md#abstraction)
    - [Encapsulation vs Abstraction vs Visibilité](https://github.com/RiriJane/8th-sem-heg/blob/main/63-31%20Prog%203/63-31_prog3.md#encapsulation-vs-abstraction-vs-visbilit%C3%A9)
    - [Héritage](https://github.com/RiriJane/8th-sem-heg/blob/main/63-31%20Prog%203/63-31_prog3.md#heritage)
    - [Polymorphisme](https://github.com/RiriJane/8th-sem-heg/blob/main/63-31%20Prog%203/63-31_prog3.md#polymorphisme)
    - [Interfaces](https://github.com/RiriJane/8th-sem-heg/blob/main/63-31%20Prog%203/63-31_prog3.md#interfaces)
    - [Attributs statiques](https://github.com/RiriJane/8th-sem-heg/blob/main/63-31%20Prog%203/63-31_prog3.md#attributs-statiques)
    - [SOLID](https://github.com/RiriJane/8th-sem-heg/blob/main/63-31%20Prog%203/63-31_prog3.md#solid)
    - [Reader](https://github.com/RiriJane/8th-sem-heg/blob/main/63-31%20Prog%203/63-31_prog3.md#reader)
    - [Exceptions](https://github.com/RiriJane/8th-sem-heg/blob/main/63-31%20Prog%203/63-31_prog3.md#exceptions)
    - [Hierarchie Classes Java](https://github.com/RiriJane/8th-sem-heg/blob/main/63-31%20Prog%203/63-31_prog3.md#hierarchie-classes-java)
    - [Comparable](https://github.com/RiriJane/8th-sem-heg/blob/main/63-31%20Prog%203/63-31_prog3.md#comparable)
    - [Comparator](https://github.com/RiriJane/8th-sem-heg/blob/main/63-31%20Prog%203/63-31_prog3.md#comparator)
2. [TAD, Enum, Types Génériques](https://github.com/RiriJane/8th-sem-heg/blob/main/63-31%20Prog%203/63-31_prog3.md#types-abstraits-de-donnees)
    - [Types abstraits de données](https://github.com/RiriJane/8th-sem-heg/blob/main/63-31%20Prog%203/63-31_prog3.md#types-abstraits-de-donnees)
    - [Classes/Types Génériques](https://github.com/RiriJane/8th-sem-heg/blob/main/63-31%20Prog%203/63-31_prog3.md#classestypes-generiques)
    - [Enumerations](https://github.com/RiriJane/8th-sem-heg/blob/main/63-31%20Prog%203/63-31_prog3.md#enumerations)

[Checklist](https://github.com/RiriJane/8th-sem-heg/blob/main/63-31%20Prog%203/63-31_prog3.md#checklist)

# REVISION PROGRAMMATION ORIENTEE OBJETS
## ENCAPSULATION
Contient toute l'information et n'expose que les données nécessaires.
- Avantage : cohérence
- But utltime : pas de paramètres à passer aux méthodes.

  ```
  c = new Client("Ludo", "Carouge");
  m = new Commande();
  m.prixHT = 100;
  m.prixExpediton = %;

  m.Facture();
  ```

## VISIBILITE DE L'INFORMATION
Private, Public, Protected, package-protected
- Utilisée pour l'encapsulation, abstraction
- Avantage : sécurité du programme, éviter les corruptions accidentelles.

![01 visbilité de l'information](img/revisionPOO/01-visibilite.jpg?raw=true)

## ABSTRACTION
On définit des objets par leur interface externe, pas par leurs détails ou leur mécanique.
- En pratique : on se demande ce qu'on besoin d'exposer
- Avantages : interface plus intuitive, on réduit l'impact des changements
- But utlime : Pas besoin d’explications ou de documentation pour utiliser
une classe.

## ENCAPSULATION VS ABSTRACTION VS VISIBILITE
Encapsulation : regroupes l’information dans des entités cohérentes.

Abstraction : n’exposer que les fonctions pertinentes, cacher les détails. On montre le "quoi" mais pas le "comment".

Visibilité : = restriction d’accès ; mécanisme pour rendre tout ça plus "propre".

## HERITAGE
Les classes peuvent réutiliser du code écrit pour d’autres classes.
- En pratique : On définit une hierarchie. Certaines classes seront des extensions, spécialisations, ou généraux.
- Avantages : réutilisation du code
- But ultime : l'écriture de l'algorithme une fois.

```
public class MotherClass {
  // Attributs
  private String att1;
  private int att2;

  // Constructor
  public MotherClass(){}

  // Method 1
  public void method1(){}
}

public class ChildClass extends MotherClass {
  // Attributs of ChildClass
  private String att1;

  // Constructor that calls the MotherClass's constructor first
  public ChildClass(){
    super();
    // initialisation after calling the parent's Constructor
    // ...
  }

  // ChildClass's method
  public void methodA(){}

  // Redefining parent's method
  public void methodB(){
    super.method1();
    // Other operations
  }
}
```

## POLYMORPHISME
Fournir des fonctions génériques afin qu'elles puissent être utilisés de manière interchangeable entre différentes classes.
- En pratique : spécifier des types génériqus pour dépendre au strict minimum.
- Avantages : flexbilité du code
- But ultime : réduire l'utilisation des "if" et "switch"

```
// 3 objects
public abstract class Animal {
  public void talk();
}

public class Dog extends Animal {
  private void bark(){ System.out.println("Woof"); }
  public void talk(){ bark(); }
}

public class Cat extends Animal {
  private void mew(){ System.out.println("Meow"); }
  public void talk(){ mew(); }
}
```
- On s'intéresse à ce que l'animal fait (capacité de parler) que ça soit une chien ou un chat

## INTERFACES
Collection des méthodes abstraites. Une sorte de contrat que les classes doivent respecter en implémentant une interface. On l’utilise pour indiquer qu’une classe "est un". Possibilité d'avoir une interface vide (tagging interface).
- La redéfinition des méthodes doivent respecter la signature de la méthode.

```
public interface MyInterface{
  private string someMethod();
  private void anotherMethod();
}

public void MyClass implements MyInterface{
  // constructor
  public MyClass(){}

  // Methods of MyClass
  private void myMethod(){}  

  // Need to redefine methods of MyInterface
  private string someMethod(){}
  private void anotherMethod(){}
}
```

## ATTRIBUTS STATIQUES
- Access aux propriétés sans avoir besoin d'instancier la classe.
- Le mot clé "this" n'est pas disponible si un attribut est déclarée en tant que static.

```
// Attribut static
public class MyClass { static int attr1; }

// Bloc static
public class MyClass {
  static {  attr1; }
}

// Constant
public class MyClass {  final static int attr1; }

```

## SOLID
| L | But | DETAILS |
|---|-----|---------|
| S | Single-Responsability | Chaque classe, fonction ont un seul role. |
| O | Open-Closed | Favoriser l'héritage, abstraction (Open to extension) mais décourager la modification (Closed to modification) |
| L | Liskov Substitution | Quand on utilise un objet d’une certaine classe, on doit pouvoir utiliser un objet dérivant de la classe sans le remarque |
| I | Interface Segregation | Eviter de rendre le code dépendant des méthodes qu'on n'utilise pas. |
| D | Dependency Inversion | Favoriser les interfaces pour minimiser les dépendances entre modules. Par exemple : plutôt que "A dépend de B", on préférera "A fournit une fonctionnalité F et B dépend de la fonctionnalité F"
|

## READER
#### CHARACTER BY CHARACTER
```
Reader fileReader = new FileReader("monFichier.txt");

int monTexte = fileReader.read();

while(monTexte != -1) {

    // Utiliser ce qu’on a lu dans monTexte
    monTexte = fileReader.read();

}

fileReader.close();
```

#### CHARACTER BY CHARACTER - VERSION 2
```
InputStream inputStream = new FileInputStream("monFichier.txt");

Reader inputStreamReader = new InputStreamReader(inputStream);

int monTexte = inputStreamReader.read();

while(monTexte != -1){

    char monChar = (char) monTexte;

    // Utiliser ce qu’on a lu dans monChar
    monTexte = inputStreamReader.read();
}

inputStreamReader.close();
```

#### BY LINE
```
BufferedReader reader = new BufferedReader(new FileReader("results.csv"));
        String ligne;
        while((ligne = reader.readLine()) != null){
            String[] champ = ligne.split(";");

            try {
                Result res = new Result(champ[0],
                        Integer.parseInt(champ[1]),
                        Integer.parseInt(champ[2]),
                        Integer.parseInt(champ[3]),
                        Integer.parseInt(champ[4]));

                results.add(res);

            }catch (NumberFormatException | IndexOutOfBoundsException e){
                System.out.println("Ligne non traitee : " + ligne);
            }

        }
```

## EXCEPTIONS
```
try {
 // Instructions qui peuvent provoquer une exception
} catch (TypeException e ){
 // Que faire si l’exception survient
}
```

![02 Tableau d'exceptions](img/revisionPOO/02-exceptions.jpg?raw=true)

#### DEFINIR SA PROPRE EXCEPTION
Une classe exception est une classe comme une autre. On peut ajouter des attributs, des méthodes, des constructeurs, faire des héritages etc.

```
public class MyException extends Exception {
 // Attributs
 int exVal;

 // Constructor
 public MyException(int x) {
   exVal = x;
 }

 // Called by printStackTrce()
 public String toString() {
   return "MyException : valeur = " + exVal;
 }

}
```

## HIERARCHIE CLASSES JAVA
- Toutes classes héritent de la class Object
- Méthodes importantes :
  - equals() : permet de décider si deux objets (et non leurs références) sont égaux.
  - clone() : crée une copie d’un objet.
  - toString() : renvoie une représentation texte de l’objet.
  - finalize() :  appelée quand le garbage collector
	 	 	 supprime l’objet.

![03 hierarchie classe java](img/revisionPOO/03-hierarchie-java.jpg?raw=true)

Interfaces à connaître :
- Serializable : l’objet peut être converti en un tableau d’octets afin d’être stocké, transmis, etc.
- Cloneable : l’objet peut être dupliqué (cloné):
- Closeable : l’objet peut être fermé (libération des ressources).
- readable : l’objet peut être lu (source de caractères).
- Iterable<T> : l’objet peut être parcouru avec une boucle "for each".
- Colelction : groupe d'objets (éléments).
- Comparable<T> : il existe un ordre total sur les éléments de la classe.

## COMPARABLE
- L’interface Comparable s’assure qu’il existe un ordre total entre les éléments de la classe.
  - Pour tous les éléments a et b appartenant à la classe, on peut toujours dire si a < b ; a == b ou a > b.
- Surcharge de la méthode int compareTo(T o):
  - Renvoie un nombre négatif si this < o
  - Renvoie 0 si et seulement si this == o
  - Renvoie un nombre positif si this > o
  - Transitif (x < y et y < z => x < z)
  - Permet de déclencher un tri

```
public class MyClass implements Comparable{
  private int attr1;

  @Override
  public int compareTo(Object o){
    return attr1.compareToIgnoreCase(((MyClass)o).attr1);
  }
}
```

## COMPARATOR
 ```
 // Replace Type
 public class MyClass implements Comparator<Type>{

   // method1() is method in MyClass
   @Override
    public int compare(MyClass o1, MyClass o2) {
        return o1.method1(o2);
    }
 }

 public class MyClass implements Comparable{

   private int anotherMethod(){ return nb; }

   public int methode1(Object o){
        return ((MyClass)o).anotherMethod() - anotherMethod();
    }

 }

 ```


# TYPES ABSTRAITS DE DONNEES
Une classe abstrait indique qu'une classe n'a pas d'implémentation complète et donc ne peut pas être instancier. Elle définit ce que la classe fait (Notions de contrat).

**CLASSE ABSTRAITE - ANIMAL**
```
public abstract class Animal {
  public abstract void move();
}
```

**SOUS-CLASSE CONCRETE - DOG**
```
public class Dog extends Animal{
  private String type;

  public void move(){
    // Some code to make the dog move...
  }
}
```

**APPLICATION - INSTANCIE LES OBJETS**
```
public class App{
  public static void main(String[] args){
    // Animal animal = new Animal(); <- PAS POSSIBLE
    Animal dog = new Dog();
  }
}
```

#### FORMALISME - 3 ELEMENTS
- Des opérations définies comme des constantes ou des primitives (fonctions mathématiques) (ensemble de départ & d’arrivée) dont découleront les signatures des méthodes.
      ListeVide : Ø → Liste(T)

      Taille : Liste(T) → ℕ

      Ajouter : T × Liste(T) → Liste(T)

      Retirer : Liste(T) → T × Liste(T)

- Des conditions de validité des opérations : Retirer valide si Taille > 0
- Des axiomes, i.e. des propriétés (sémantique) qui sont tout le temps vraies ; définissent le
comportement
      Taille(ListeVide()) = 0

      Taille(Ajouter(x, L)) > 0

      Retirer(Ajouter(x, L)) = (x, L)

#### POURQUOI UTILISER DES FORMALISME
- Une Spécification algébrique
- Permet de convenir d’un ensemble de fonctions avec des non-informaticiens
- Permet de définir un contrat de vérification de l’implémentation
- Architecture plus modulaire : on utilise des TAD plutôt que des types concrets dans
le code pour être indépendants de l’application

# CLASSES/TYPES GENERIQUES
Les types génériques permettent de définir explicitement les types d'objets que contienne la classe.

- On peut utiliser plusieurs classes paramètres : ```public class MaClasseGenerique <ClasseDeBase, AutreClasse, EncoreUne>```
- Utiliser les interfaces et héritages ```public class MaClasseGenerique <A, B> extends MaClasse<A> implements MonInterface<A,B>```

**Attention** : Si classe B hérite de A, on ne peut pas définir une fonction qui prenne paramètre classeA et accepte les deux paramètres.

- On peut déclarer dans une classe normale, une méthode génériques :
```
public class MaClasse {
  public static <T> T maMethode(T[] tableaudeT) { ... }
}
```


#### EXEMPLE AVEC LES ARRAYLISTS
```
public class app{
  public static void main(String[] args){
    ArrayList notGeneric = new ArrayList();
    ArrayList<Integer> generics = new ArrayList<Integer>();

    notGeneric.add(1);
    notGeneric.add("Hello"); // Not what we want but no error thrown since there is no type declared


    generics.add(1);
    generics.add(11);
    generics.add("Hello"); // Not possible - error thrown

  }

}
```

#### EXEMPLE EN CREANT NOTRE PROPRE CLASSE DE TYPES GENERIQUES
**CLASS GENERIQUE - MyList**
```
public class MyList<T1>{
  private ArrayList<T1> list = new ArrayList<T1>();

  public void add(int num)(){ // code to add number in the list }
}
```

**APPLICATION - INSTANCIE LES OBJETS**
```
public class app{
  public static void main(String[] args){
    MyList<String> lst = new MyList<String>();

    lst.add(12);
    lst.add("Hello") // Not possible, error thrown
  }

}
```

# ENUMERATIONS
Une énumération est une liste de valeurs restreintes.
- Exemple : {Bleu, Rouge, Jaune, Orange, Vert}

Une énumération est une classe qui dérive de la classe Enum. Quelques méthodes notables :
- toString() : Renvoie une chaîne de caractères qui correspond à la valeur de l’élément
- valueOf() : Renvoie la valeur de l’énumération à partir d’une chaîne de caractères
- values() : Liste les valeurs possibles de l’énumération (tableau)
- ordinal() : Donne l’index (démarre à 0) d’une valeur dans une énumération
- compareTo() : comparaison sur la base des numéros d’index

#### DECLARATION
```
public enum Couleur {BLEU, ROUGE, JAUNE, ORANGE, VERT}
```
#### EXEMPLE DE CODE
```
class TestEnum {
  enum Couleur {BLEU, ROUGE, JAUNE, ORANGE, VERT}

  public static void main(String[] args){
    System.out.println("Couleur du ciel : " + Couleur.BLEU);
  }
}
```

#### CREATION D'UNE CLASSE ENUM
```
public enum Couleur {
  BLEU("#0084D1"), ROUGE("#C5000B"), JAUNE("#FFD320"), ORANGE("#FF8000"), VERT("#008000")
  private String codeRGB;

  private Couleur(String rgb) {
    this.codeRGB = rgb;
  }

  public String RGB() {
    return this.codeRGB;
  }
}
```

# EXTENSION DE FONCTIONNALITE
- Privilégier la méthode 4 (wrapper) pour ajouter des attributs
- Privilégier la méthode 5 (interface) pour ajouter des méthodes/comportements

## CLASSE ENVELOPPE - WRAPPER
![01 - wrapper](img/ext-fonctionnalite/01-wrapper.jpg?raw=true)
- une classe abstraite FigureDessinable va mémoriser (dans un attribut) une instance concrète de Figure
- les méthodes de Figure sont implémentées par délégation
- on dérive de FigureDessinable les classes RectangleDessinable et CercleDessinable
- principe du design pattern Adapter
- voir 02) WrapperDessinable
- Inconvénients:
		- on ne pourra wrapper que des Figure existantes (Rectangle et Cercle), pas des Triangle
		- ça ne fonctionne qu'avec des Figure, pas utilisable pour un autre objet (String)

## INTERFACE
![02 - interface](img/ext-fonctionnalite/02-interface.jpg?raw=true)
- l'interface Dessinable est une classe abstraite, ne définissant que des méthodes abstraites
- RectangleDessinable sera dérivé de Rectangle, et implements l'interface Dessinable
- RectangleDessinable conserve ainsi ses caractéristiques provenant de Figure
- le concept d'interface permet de regrouper des classes du point de vue de leur comportement
- on pourra utiliser cet interface Dessinable pour n'importe quel objet (pas que des Figure)
















# CHECKLIST
- [ ] Créer et exécuter un programme simple en Java
- [ ] Expliquer la différence entre une classe et un type de base (int, float, …)
- [ ] Déclarer une classe
- [ ] Instancier des objets et les utiliser
- [ ] Définir ce qui doit être exposé (public, private, protected)
- [ ] Faire la différence entre une classe abstraite et une interface
- [ ] Créer une classe héritant d’une autre classe
- [ ] Déclarer qu’une classe implémente une ou plusieurs interfaces
- [ ] Utiliser le polymorphisme
- [ ] Déclarer et utiliser des attributs et des méthodes statiques
